// <auto-generated />
using System;
using Infrastructure.Persistance;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace Infrastructure.Persistance.Migrations
{
    [DbContext(typeof(NewsletterContext))]
    [Migration("20240906085711_comments")]
    partial class comments
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.7")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("Domain.Articles.Article", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("Author")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<DateTime>("EditedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("MarkdownContent")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<byte[]>("Version")
                        .IsRequired()
                        .HasColumnType("varbinary(max)");

                    b.HasKey("Id");

                    b.ToTable("Articles", (string)null);

                    b.HasData(
                        new
                        {
                            Id = 1,
                            Author = "Sultan Dzhumaev",
                            CreatedDate = new DateTime(2024, 8, 10, 0, 0, 0, 0, DateTimeKind.Utc),
                            EditedDate = new DateTime(2024, 8, 10, 0, 0, 0, 0, DateTimeKind.Utc),
                            MarkdownContent = "When working with distributed systems, there are many factors to consider, including the environment you are operating in, ensuring the relevant configurations are up and running, and maintaining communication between the services and components. One common pitfall in developing a distributed system is not having a smart way to manage all the key-value pair configurations used for service-to-service communication, database connections, and other integrations. This challenge is more severe when you need to differentiate between various environment configurations and maintain each one of them.\r\n\r\nAnother difficulty in working with such systems arises when using different vendors' SDKs to integrate with their resources. This approach often results in a strong coupling to that specific infrastructure within your code, which might not be desirable, particularly when moving between local development environments and staging environments in the cloud.\r\n\r\nThis is where Dapr comes into play, addressing these problems and more.\r\n\r\nDapr is a runtime application designed to be a handy tool for distributed systems, helping achieve quality attributes like resilience, maintainability, and scalability. It accomplishes this by offering \"building blocks,\" each a coherent set of APIs tailored to specific feature.\r\n\r\nDapr is fully supported with the latest .NET and C# with SDK library, and even more the Dapr itself tries to support variety of different programming languages. Dapr is an open source project written in GO language. \r\n\r\n## Sidecar Pattern\r\nA significant feature of the Dapr runtime is its implementation of the sidecar pattern. In this pattern, every microservice has its own dedicated sidecar application running alongside it. The core principle here is that your main service contains the essential business logic and features, while cross-cutting concerns are offloaded to its sidecar.\r\n\r\nIn the context of Dapr, these cross-cutting concerns are particularly interesting because by offloading responsibilities to Dapr for communicating with different outbound sources, your microservice is relieved from integrating directly with vendor SDKs. Instead, it interacts with a consistent set of Dapr APIs, independent of the underlying infrastructure.\r\n\r\nEach Dapr sidecar exposes APIs for metadata, health checks, and building blocks. The metadata and health APIs are used for load balancing and discovering the appropriate destinations for communication.\r\n\r\n<figure>\r\n  <img src=\"./sidecars.svg\" alt=\"Cluster with services and sidecars\" width=\"100%\"/>\r\n  <figcaption>Amount of service instances will always match with amount of spawned sidecars in a Kubernetes based cluster</figcaption>\r\n</figure>\r\n\r\n\r\n## Dapr Components\r\nDapr components are pluggable units that provide integration with various external systems and resources. These components enable the system to interact with different resources such as state stores, message brokers, bindings, and observability tools. By leveraging Dapr components, developers can switch between different infrastructure providers without changing application code, enhancing the portability and flexibility of the distributed system.\r\n\r\n<figure>\r\n  <img src=\"./DaprComponent.svg\" alt=\"different components depending on your environment\" width=\"100%\"/>\r\n  <figcaption>The ability to swap between different components depending on your environment for the same building block</figcaption>\r\n</figure>\r\n\r\n\r\nDapr components are declared in YAML configuration files. These declarations specify how Dapr should interact with external resources and define the metadata and configuration details necessary for integration. Components can be used by Dapr's building blocks to perform various operations like state management, publish/subscribe messaging, and resource binding.\r\n\r\nExample Component Declaration\r\nBelow is an example of a YAML file that configures a Redis state store component for use by the Dapr state management building block:\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \"><span style=\"color: rgb(121, 192, 255); font-weight: 400;\">apiVersion:</span> <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">dapr.io/v1alpha1</span>\r\n<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">kind:</span> <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">Component</span>\r\n<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">metadata:</span>\r\n  <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">name:</span> <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">statestore</span>\r\n  <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">namespace:</span> <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">default</span>\r\n<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">spec:</span>\r\n  <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">type:</span> <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">state.redis</span>\r\n  <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">version:</span> <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">v1</span>\r\n  <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">metadata:</span>\r\n  <span style=\"color: rgb(242, 204, 96); font-weight: 400;\">-</span> <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">name:</span> <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">redisHost</span>\r\n    <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">value:</span> <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"localhost:6379\"</span>\r\n  <span style=\"color: rgb(242, 204, 96); font-weight: 400;\">-</span> <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">name:</span> <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">redisPassword</span>\r\n    <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">value:</span> <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"\"</span></pre>\r\nIn this example, the component is given a name (statestore) and specifies the type (state.redis) and version (v1). The metadata section contains key-value pairs needed to configure the Redis connection.\r\n\r\n\r\n## Dapr Building Blocks\r\n\r\nDapr building blocks are modular APIs that provide essential functionality for building distributed applications. They abstract away the complexities of working with various infrastructure components, allowing developers to focus on business logic. Dapr building blocks utilize Dapr Component declarations to provide various capabilities to your applications. A service depends on building block API and the building block depends on Component declarations that determines it behavior. Summary of building blocks shown below:\r\n\r\n\r\n<figure>\r\n  <img src=\"https://docs.dapr.io/images/building_blocks.png\" alt=\"Dapr Building Blocks\" width=\"100%\"/>\r\n  <figcaption>Dapr Building Blocks <i>Source link: <a href=\"https://docs.dapr.io/images/building_blocks.png\">https://docs.dapr.io/images/building_blocks.png</a></i></figcaption>\r\n</figure>\r\n\r\n## Azure Support\r\n\r\nIn Azure, there is a Kubernetes-based serverless hosting platform called Container Apps, which natively integrates with Dapr. By enabling this feature, the cloud provider manages and provisions the necessary resources for Dapr to operate and allocates the sidecar containers. Both from the Azure portal GUI and with Infrastructure as Code (IaC) tools such as Bicep, you can configure all of the required Dapr settings within this resource platform.\r\n\r\nContainer Apps is a good candidate for deploying your microservices and provides layers of abstraction that make it easier to provision your containers, as the underlying Kubernetes infrastructure is maintained by the cloud provider.\r\n\r\nOne limitation is that any Dapr building block that is either in the Alpha or Beta stage will not be supported in this hosting platform until it reaches a stable stage version.\r\n\r\n<figure>\r\n  <img src=\"https://learn.microsoft.com/en-gb/azure/container-apps/media/microservices-dapr/azure-container-apps-microservices-dapr.png\" alt=\">Dapr Container apps deployed in runtime with Dapr\" width=\"100%\"/>\r\n  <figcaption>Dapr Container apps deployed in runtime with Dapr <i>Source link: <a href=\"https://learn.microsoft.com/en-gb/azure/container-apps/media/microservices-dapr/azure-container-apps-microservices-dapr.png\">https://learn.microsoft.com/en-gb/azure/container-apps/media/microservices-dapr/azure-container-apps-microservices-dapr.png</a></i></figcaption>\r\n</figure>\r\n\r\n## Service-to-Service Invocation\r\nThe service-to-service invocation building block is a fundamental part of Dapr, enabling microservices to communicate with each other efficiently and reliably. This building block abstracts the complexities of service discovery and routing, allowing developers to focus on their business logic without worrying about the network communication or base URL of the service to be invoked.\r\n\r\n* Service Discovery: Dapr automatically handles service discovery, allowing services to locate and communicate with each other without hard-coded addresses.\r\n\r\n* Load Balancing: The Dapr runtime includes load balancing mechanisms, ensuring requests are distributed evenly across service instances.\r\n\r\n* Protocol Agnostic: Supports both HTTP and gRPC, allowing developers to choose the communication protocol that best suits their needs.\r\n\r\n* Security: Dapr supports secure communication between services using mutual TLS, ensuring data privacy and integrity.\r\n\r\nBy using Dapr's service-to-service invocation building block, developers can bridge http/grpc communication without the overhead of managing it.\r\n\r\n\r\n## Example Scenario: ServiceA invocating ServiceB for fetching WeatherForecast\r\n\r\nWe start the dapr sidecars in self-hosted mode, and relative to where the csprojects  are located in the file system, we create two ps.1 scripts which will tell the dapr CLI to start both the dotnet application, sidecar and bind it to services. Pay attention to --resources-path parameter, which tells where the dapr components are stored.\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \">dapr run <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">--app-id</span> serviceA <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">--app-port</span> <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">5203</span> <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">--resources-path</span> ..\\dapr.components\\ <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">--</span> dotnet run\r\n\r\ndapr run <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">--app-id</span> serviceB <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">--app-port</span> <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">5204</span> <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">--resources-path</span> ..\\dapr.components\\ <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">--</span> dotnet run</pre>\r\n\r\nYou need to install nuget package **Dapr.AspNetCore**.\r\n\r\nThis library will provide an extension method to IServiceCollection, you will need to configure Dapr Dependency Injection as following:\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \">builder.Services.AddDaprClient();\r\n</pre>\r\n\r\nThe code below for ServiceA showcases multiple ways to archieve the same service invocation capability.\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">using</span> Dapr.Client;\r\n<span style=\"color: rgb(255, 123, 114); font-weight: 400;\">using</span> Microsoft.AspNetCore.Mvc;\r\n\r\n<span style=\"color: rgb(255, 123, 114); font-weight: 400;\">namespace</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">dapr.serviceA</span>;\r\n\r\n[<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">Route(<span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"/\"</span>)</span>]\r\n<span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">class</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">ServiceAController</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">\r\n    DaprClient client</span>) : ControllerBase</span>\r\n{\r\n\r\n    [<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">HttpGet(<span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"/forecast1\"</span>)</span>]\r\n    <span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">async</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">Task</span>&lt;<span style=\"color: rgb(210, 168, 255); font-weight: 400;\">IActionResult</span>&gt; <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">GetForecast</span>()</span>\r\n    {\r\n        <span style=\"color: rgb(139, 148, 158); font-weight: 400;\">// Several overloads of InvokeMethodAsync, and ability to strongly bind contracts.</span>\r\n        <span style=\"color: rgb(139, 148, 158); font-weight: 400;\">//Response WITHOUT request payload</span>\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> client.InvokeMethodAsync&lt;WeatherForecast[]&gt;(httpMethod: HttpMethod.Get, appId: <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"serviceB\"</span>, methodName: <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"forecast\"</span>);\r\n\r\n        <span style=\"color: rgb(139, 148, 158); font-weight: 400;\">//Response with request payload</span>\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> client.InvokeMethodAsync&lt;<span style=\"color: rgb(255, 166, 87); font-weight: 400;\">int</span>, WeatherForecast[]&gt;(httpMethod: HttpMethod.Post, appId: <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"serviceB\"</span>, data: <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">100</span>, methodName: <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"forecast\"</span>);\r\n\r\n        <span style=\"color: rgb(139, 148, 158); font-weight: 400;\">//Either response contract will be returned in case of valid HTTP status, or an exception will be raised in above methods</span>\r\n        <span style=\"color: rgb(139, 148, 158); font-weight: 400;\">//Alternative is to use InvokeMethodWithResponseAsync, granular control in case of failure</span>\r\n        HttpRequestMessage request = client.CreateInvokeMethodRequest(appId: <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"serviceB\"</span>, methodName: <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"forecast2\"</span>);\r\n\r\n        HttpResponseMessage response = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> client.InvokeMethodWithResponseAsync(request);\r\n    }\r\n}</pre>\r\n\r\nThe dapr sidecar will discover the appropriate endpoint to call in ServiceB as long as the relative route path of the endpoint matches with the methodName parameter passed above.\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">using</span> Dapr.Client;\r\n<span style=\"color: rgb(255, 123, 114); font-weight: 400;\">using</span> Microsoft.AspNetCore.Mvc;\r\n\r\n<span style=\"color: rgb(255, 123, 114); font-weight: 400;\">namespace</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">dapr.serviceB</span>;\r\n\r\n[<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">Route(<span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"/\"</span>)</span>]\r\n<span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">class</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">ServiceBController</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">\r\n    DaprClient client</span>) : ControllerBase</span>\r\n{\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">private</span> <span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span>[] summaries = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">new</span>[]\r\n        {\r\n            <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"Freezing\"</span>, <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"Bracing\"</span>, <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"Chilly\"</span>, <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"Cool\"</span>, <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"Mild\"</span>\r\n        };\r\n\r\n    [<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">HttpGet(<span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"/forecast2\"</span>)</span>]\r\n    <span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">async</span> Task&lt;IActionResult&gt; <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">GetForecast</span>()</span>\r\n    {\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">return</span> Ok(Enumerable.Range(<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">1</span>, <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">5</span>).Select(index =&gt;\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">new</span> WeatherForecast\r\n        (\r\n            DateOnly.FromDateTime(DateTime.Now.AddDays(index)),\r\n            Random.Shared.Next(<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">-20</span>, <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">55</span>),\r\n            summaries[Random.Shared.Next(summaries.Length)]\r\n        ))\r\n        .ToArray());\r\n    }\r\n}</pre>\r\n\r\nPlease refer to the official Dapr documentation on how to start using it with different hosting models:\r\n\r\n<a href=\"https://docs.dapr.io/operations/hosting/\">Documentation</a>\r\n\r\n## Conclusion\r\n\r\nDapr is a powerful tool that makes it easier to develop and distribute microservices due to its powerful building blocks. We only demonstrated the service invocation capability of Dapr in this post. In future posts, we will explore other capabilities. A real constraint of Dapr is that not all of its budling block APIs are in a stable version. Depending on your needs, infrastructure, and platform you are hosting your system on, this will dictate which features are production-ready and which are not. Reading the documentation and tracking GitHub issues may save you the trouble of reproducing the same error in your execution environment.\r\n",
                            Title = "Dapr Introduction and Service-to-Service Invocation Part I",
                            Version = new byte[0]
                        },
                        new
                        {
                            Id = 2,
                            Author = "Sultan Dzhumaev",
                            CreatedDate = new DateTime(2024, 8, 31, 0, 0, 0, 0, DateTimeKind.Utc),
                            EditedDate = new DateTime(2024, 8, 31, 0, 0, 0, 0, DateTimeKind.Utc),
                            MarkdownContent = "One of the characteristics of a well-implemented Web API is its use of available tools and strategies to increase the efficiency of request execution. Efficiency can refer to various factors, including execution time, data consistency, hardware consumption, and appropriate validation of inputs.\r\n\r\nIn this article, titled \"Implementing the Cache-Aside Pattern with MediatR,\" we will focus on optimizing execution time. I will be using the MediatR library to demonstrate how it is possible to implement this caching strategy as a cross-cutting concern, where the type of request will determine the behavior of the flow. We won't delve deeply into the Mediator pattern implemented by the MediatR library or other complementary patterns for this caching strategy, as they deserve their own articles.\r\n\r\nCache-Aside Pattern\r\nThis pattern focuses on recurring queries performed against an application, thereby storing the state of the query responses. This strategy is useful if you want to increase the performance, and hence increasing the execution time of your application. Also in case of outrage of the database or external API, this pattern encourages data replication so that the data will be available as a cache even if the primary source is down.\r\n\r\nIn the CQRS pattern, there is a clear distinction between requests that are of type queries (read operations) and commands (write operations). In a layered architecture, following CQRS provides a structured flow for how queries and commands propagate, are processed, and how resources are allocated.\r\n\r\nCache-Aside emphasizes using queries as the source for temporarily caching data, which can then be retrieved when identical queries are executed. The sum of primary key properties of the query object will be used to cache the result and perform the recurring cache fetch if the response already exists. The illustrations below showcase the relevant scenarios.\r\n\r\n<figure>\r\n  <img src=\"./cache_aside_1.svg\" alt=\"Cache-Aside Flow\" width=\"100%\"/>\r\n  <figcaption>First time when frontend GET calls the backend for resource ID 1</figcaption>\r\n</figure>\r\n\r\n1. The frontend performs a GET request with ID 1.\r\n2. The backend checks if the response is already cached in the cache storage. Result: NOT FOUND.\r\n3. The backend performs a database call to fetch the data from the persistent data storage. Result: OK.\r\n4. The backend stores the response in the cache based on data from persistent storage with key ID 1. Result: OK.\r\n5. The backend responds to the frontend with an OK status, including the payload.\r\n\r\nNow the cache is populated with the state reflecting the resource with ID 1. The next time the frontend makes the same request with ID 1, the flow will have a shortcut to acquire the needed data, thereby boosting execution time and responsiveness for the client on the frontend side.\r\n\r\n<figure>\r\n  <img src=\"./cache_aside_2.svg\" alt=\"Cache-Aside Flow\" width=\"100%\"/>\r\n  <figcaption>Second time when frontend GET calls the backend for resource ID 1</figcaption>\r\n</figure>\r\n\r\n1. The frontend performs a GET request with ID 1.\r\n2. The backend checks if the response is already cached in the cache storage. Result: OK.\r\n3. The backend responds to the frontend with an OK status, including the payload.\r\n\r\nIt's no wonder the backend will respond quickly this time since we managed to bypass two roundtrips, both to the cache and the database storages. This is especially beneficial if the response object results from extensive computation, such as projection/aggregation, as the backend won't need to perform the same logic to derive the same result.\r\n\r\n## Drawbacks\r\nWhile the benefits of this pattern are clear, it's important to consider potential drawbacks, such as data quality and synchronization issues. What happens when the resource with ID 1 is updated or deleted? Without additional logic to compensate for these actions, the cache storage would be completely unaware of any PUT, PATCH, or DELETE operations performed on the resource with ID 1 in persistent storage. This means that the next time the frontend calls for ID 1, it could receive the cached OK response instead of the correct NOT FOUND response.\r\n\r\nTo address this issue, a proposed solution is to equip commands with a list of keys to invalidate in the cache storage. For example, if ID 1 was deleted, the command should invalidate the cache for both fetching ID 1 and retrieving all related resources, as shown in the illustration below.\r\n\r\n<figure>\r\n  <img src=\"./cache_aside_3.svg\" alt=\"Cache-Aside Flow with invaldiation\" width=\"100%\"/>\r\n  <figcaption>Frontend performs command call to the backend for resource ID 1</figcaption>\r\n</figure>\r\n\r\n1. The frontend performs a PUT/PATCH/DELETE request with ID 1.\r\n2. The backend executes the core command handler logic and persists the changes in the database. Result: OK.\r\n3. The backend invalidates the cache with the list of keys associated with the command. Result: OK.\r\n4. The backend responds to the frontend with an OK status.\r\n\r\nAnother drawback of this pattern is the introduction of a new integration to the backend. As a general rule, any integration may occasionally fail. What happens if, for some reason, the backend doesn't receive a response from the cache storage instance after the command operation has been persisted in the database? This is something developers must consider in their overall assessment. What are the costs of a temporary \"unsynchronized\" state between the cache and the database if a failure occurs? While this may be an edge case consideration, and the flow might perform as intended 99.999% of the time, you must determine whether the solution can tolerate the 0.001% failure rate. Eventual consistency with messaging might be the answer, but that is outside the scope of this article.\r\n\r\nNow to be fair on this pattern, it works also the other way. If the persistent storage is down at a given moment,  but you have the cache response available, then the frontend will still receive the data needed for the UI.\r\n\r\nWith the implementation proposal I want to share, we are not forced to use this caching strategy everywhere. Rather, it's up to the developer to decide which types of query handlers to cache and which should not have it.\r\n\r\n## Implementation\r\nLet's start by implementing the CacheService, which will be the main service component invoked by both query and command handler flows.\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">interface</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">ICacheService</span>\r\n{\r\n    Task&lt;T?&gt; GetOrAddCache&lt;T&gt;(<span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span> key, RequestHandlerDelegate&lt;T&gt; handler, TimeSpan expiry);\r\n    <span style=\"color: rgb(201, 209, 217); font-weight: 400;\">Task <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">RemoveCache</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span>[] keys</span>)</span>;\r\n}\r\n\r\n<span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">class</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">CacheService</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">IDistributedCache cache</span>) : ICacheService</span>\r\n{\r\n    <span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">async</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">Task</span>&lt;<span style=\"color: rgb(210, 168, 255); font-weight: 400;\">T</span>?&gt; <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">GetOrAddCache</span>&lt;<span style=\"color: rgb(210, 168, 255); font-weight: 400;\">T</span>&gt;(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span> key, RequestHandlerDelegate&lt;T&gt; handler, TimeSpan expiry</span>)</span>\r\n    {\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> cachedValue = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> cache.GetStringAsync(key);\r\n\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">if</span> (!<span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span>.IsNullOrWhiteSpace(cachedValue))\r\n        {\r\n            <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">return</span> JsonSerializer.Deserialize&lt;T&gt;(cachedValue);\r\n        }\r\n\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> result = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> handler();\r\n\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">if</span> (result == <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">null</span>) <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">return</span> <span style=\"color: rgb(121, 192, 255); font-weight: 400;\">default</span>;\r\n\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> cache.SetStringAsync(key, JsonSerializer.Serialize(result), <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">new</span> DistributedCacheEntryOptions\r\n        {\r\n            SlidingExpiration = expiry,\r\n            AbsoluteExpiration = DateTime.Today.AddDays(<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">1</span>)\r\n        });\r\n\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">return</span> result;\r\n    }\r\n\r\n    <span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">async</span> Task <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">RemoveCache</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span>[] keys</span>)</span>\r\n    {\r\n        List&lt;Task&gt; tasks = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">new</span>();\r\n\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">foreach</span> (<span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> key <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">in</span> keys)\r\n        {\r\n            tasks.Add(cache.RemoveAsync(key));\r\n        }\r\n\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> Task.WhenAll(tasks);\r\n    }\r\n}</pre>\r\n\r\n\r\nIn this example, I am using IDistributedCache, an abstraction provided by the Microsoft.Extensions namespace. Under the hood, you can decide whether to use an in-memory cache, a distributed cache like Redis, etc. RequestHandlerDelegate is a delegate type representing an asynchronous task to be performed, defined in the MediatR namespace. This is used for chaining the different behavior handlers of the MediatR pipeline. It will be provided by the relevant behavior pipelines when invoking the CacheService.\r\n\r\nThe GetOrAddCache method contains the logic to decide whether to execute the delegate representing the core handler logic or acquire the cached data and return early with the response.\r\n\r\nYou need to install the NuGet package MediatR to follow this code implementation.\r\n\r\nNext, we define an interface representing queries eligible for caching, which must implement a key property. This interface is an extension of the base interface provided by MediatR (IRequest) and respects the generic type to be defined.\r\n\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">interface</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">ICachedQuery</span>&lt;<span style=\"color: rgb(210, 168, 255); font-weight: 400;\">TResponse</span>&gt; : <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">IRequest</span>&lt;<span style=\"color: rgb(210, 168, 255); font-weight: 400;\">TResponse</span>&gt;\r\n{\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span> Key { <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">get</span>; }\r\n}</pre>\r\n\r\nNow, let's implement the behavior pipeline representing the cross-cutting logic for handling queries that inherit ICachedQuery.\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \"><span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">class</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">CachedQueryHandlerPipelineBehavior</span>&lt;<span style=\"color: rgb(210, 168, 255); font-weight: 400;\">TRequest</span>, <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">TResponse</span>&gt;(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">\r\n    ICacheService cacheService</span>) : IPipelineBehavior&lt;TRequest, TResponse&gt;\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">where</span> TRequest : ICachedQuery&lt;TResponse&gt;</span>\r\n{\r\n    <span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> Task&lt;TResponse&gt; <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">Handle</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">TRequest request, RequestHandlerDelegate&lt;TResponse&gt; next, CancellationToken cancellationToken</span>)</span>\r\n    {\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> result = cacheService.GetOrAddCache(request.Key, handler: next, expiry: TimeSpan.FromMinutes(<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">5</span>));\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">return</span> result!;\r\n    }\r\n}</pre>\r\n\r\nNote the constraints we are placing on the generic type TRequest. When we inherit the base IPipelineBehavior<TRequest, TResponse>, we specify that this pipeline component should only be invoked when the incoming IRequest is of a type that implements ICachedQuery. Essentially, we are separating the concern of regular queries from those that require caching.\r\n\r\nWe have access to the Key property, which is defined and implemented. This will be used by the CacheService to fetch and potentially cache the response of the delegate. When implementing the IPipelineBehavior, the method signature includes a delegate parameter of type RequestHandlerDelegate. This delegate is passed throughout the pipeline and used by the CacheService.\r\n\r\nNext, we define an interface for commands that expands on the base IRequest interface. This interface includes an array of keys that the CacheService will use to remove the associated cached data.\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">interface</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">IInvalidateCacheCommand</span>&lt;<span style=\"color: rgb(210, 168, 255); font-weight: 400;\">TResponse</span>&gt; : <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">IRequest</span>&lt;<span style=\"color: rgb(210, 168, 255); font-weight: 400;\">TResponse</span>&gt;\r\n{\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span>[] InvalidateKeys { <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">get</span>; }\r\n}</pre>\r\n\r\nFinally, we implement the behavior pipeline representing the cross-cutting logic for invalidating the cache before executing the core command handler logic.\r\n\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \"><span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">class</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">InvalidateCacheCommandHandlerPipelineBehavior</span>&lt;<span style=\"color: rgb(210, 168, 255); font-weight: 400;\">TRequest</span>, <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">TResponse</span>&gt;(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">\r\n    ICacheService cacheService</span>) : IPipelineBehavior&lt;TRequest, TResponse?&gt;\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">where</span> TRequest : IInvalidateCacheCommand&lt;TResponse&gt;</span>\r\n{\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">async</span> Task&lt;TResponse?&gt; Handle(TRequest request, RequestHandlerDelegate&lt;TResponse?&gt; next, CancellationToken cancellationToken)\r\n    {\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> cacheService.RemoveCache(request.InvalidateKeys);\r\n\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> response = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> next();\r\n\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">return</span> response;\r\n    }\r\n}</pre>\r\n\r\nBelow are the extension methods provided by MediatR for configuring DI, registering the handlers, and adding behavior pipelines:\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \">builder.Services.AddMediatR(options =&gt;\r\n{\r\n    options.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());\r\n    options.AddBehavior(<span style=\"color: rgb(255, 123, 114); font-weight: 400;\">typeof</span>(IPipelineBehavior&lt;,&gt;), <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">typeof</span>(CachedQueryHandlerPipelineBehavior&lt;,&gt;));\r\n    options.AddBehavior(<span style=\"color: rgb(255, 123, 114); font-weight: 400;\">typeof</span>(IPipelineBehavior&lt;,&gt;), <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">typeof</span>(InvalidateCacheCommandHandlerPipelineBehavior&lt;,&gt;));\r\n});</pre>\r\n\r\nNow the MedianR library is configured to use the behavior pipelines for handling queries and commands. The CacheService is responsible for fetching and caching the data, while the behavior pipelines are responsible for invoking the CacheService and invalidating the cache when necessary.\r\n\r\nHere is an example of a Controller that uses the MediatR library to send a query and a command to respective handlers and the contracts that inherit the caching interfaces.\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \"><span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">record</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">CompleteTodoCommand</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">Guid Id</span>) : IInvalidateCacheCommand&lt;CompleteTodoResponse&gt;</span>\r\n{\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span>[] InvalidateKeys =&gt; [\r\n        <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"GET_TODOS\"</span>,\r\n        <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">$\"GET_TODO:<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">{Id}</span>\"</span>];\r\n}\r\n\r\n<span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">record</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">AddTodoCommand</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span> Content, <span style=\"color: rgb(255, 166, 87); font-weight: 400;\">bool</span> Completed</span>) : IInvalidateCacheCommand&lt;AddTodoResponse&gt;</span>\r\n{\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span>[] InvalidateKeys =&gt; [<span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"GET_TODOS\"</span>];\r\n}\r\n\r\n<span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">record</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">GetTodoByIdQuery</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">Guid Id</span>) : ICachedQuery&lt;GetTodoByIdResponse&gt;</span>\r\n{\r\n	<span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 166, 87); font-weight: 400;\">string</span> Key =&gt; <span style=\"color: rgb(165, 214, 255); font-weight: 400;\">$\"GET_TODO:<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">{Id}</span>\"</span>;\r\n}\r\n\r\n\r\n<span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">class</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">TodoController</span> : <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">ControllerBase</span>\r\n{\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">private</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">readonly</span> IMediator _mediator;\r\n\r\n    <span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">AddTodoController</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">IMediator mediator</span>)</span>\r\n    {\r\n        _mediator = mediator;\r\n    }\r\n\r\n    [<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">HttpPost(<span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"todos\"</span>)</span>]\r\n    <span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">async</span> Task&lt;IActionResult&gt; <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">AddTodoAsync</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">AddTodoCommand command</span>)</span>\r\n    {\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> response = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> _mediator.Send(command);\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">return</span> Ok(response);\r\n    }\r\n\r\n    [<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">HttpPut(<span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"todos/{id}/complete\"</span>)</span>]\r\n    <span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">async</span> Task&lt;IActionResult&gt; <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">CompleteTodo</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">Guid id</span>)</span>\r\n    {\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> command = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">new</span> CompleteTodoCommand(id);\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> result = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> _mediator.Send(command);\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">return</span> Ok(result);\r\n    }\r\n\r\n    [<span style=\"color: rgb(121, 192, 255); font-weight: 400;\">HttpGet(<span style=\"color: rgb(165, 214, 255); font-weight: 400;\">\"todos/{id}\"</span>)</span>]\r\n    <span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">async</span> Task&lt;IActionResult&gt; <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">GetTodoById</span>(<span style=\"color: rgb(201, 209, 217); font-weight: 400;\">Guid id</span>)</span>\r\n    {\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> query = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">new</span> GetTodoByIdQuery(id);\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> response = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> _mediator.Send(query);\r\n\r\n        <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">return</span> Ok(response);\r\n    }\r\n}</pre>\r\n\r\n\r\n\r\n## Scenario: Multi-Step Data Retrieval\r\n\r\nImagine a scenario where your application needs to retrieve data from an external API and database. The code might look something like this:\r\n\r\n<pre style=\"font-family:monospace;color: rgb(201, 209, 217); background-color: rgb(13, 17, 23); font-weight: 400; \"><span style=\"color: rgb(201, 209, 217); font-weight: 400;\"><span style=\"color: rgb(255, 123, 114); font-weight: 400;\">public</span> <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">async</span> Task&lt;ProcessedData&gt; <span style=\"color: rgb(210, 168, 255); font-weight: 400;\">GetAndProcessDataAsync</span>()</span>\r\n{\r\n    <span style=\"color: rgb(139, 148, 158); font-weight: 400;\">// Fetch data from an external API</span>\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> externalData = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> externalApi.GetResource();\r\n\r\n    <span style=\"color: rgb(139, 148, 158); font-weight: 400;\">// Fetch data from the database</span>\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> dbData = <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">await</span> dbContext.ProcessData(externalData.Id);\r\n\r\n    <span style=\"color: rgb(139, 148, 158); font-weight: 400;\">// Perform aggregation or projection on the fetched dbData</span>\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">var</span> finalData = PerformCostlyAggregationOrProjection(dbData);\r\n\r\n    <span style=\"color: rgb(139, 148, 158); font-weight: 400;\">// Return the final processed data</span>\r\n    <span style=\"color: rgb(255, 123, 114); font-weight: 400;\">return</span> finalData;\r\n}</pre>\r\n\r\nThe externalApi.GetResource() call can take up to several seconds to complete. After retrieving the external data, the application processes it and performs a database operation using dbContext.GetData(externalData.Id). This can be a time-consuming process, depending on the complexity of the data size fetching and the size of the database. Finally, the fetched data undergoes a costly aggregation or projection, which involves additional computation. This could include complex calculations, data transformations, or aggregating large datasets. This step can be particularly time-consuming and could further delay the response to the user.\r\n\r\nIf this method is called frequently, the repeated API calls, database queries, and costly aggregation/projection operations can create a substantial performance bottleneck. Each execution could take several seconds, leading to latency issues and a poor user experience.\r\n\r\nBy implementing caching in scenarios where your application involves costly operations, such as external API calls, database queries, and intensive aggregation or projection tasks, you can significantly improve performance. The Cache-Aside pattern allows you to avoid unnecessary delays, improving the performance and speed of your application.\r\n\r\n\r\n## Conclusion\r\nIncorporating the Cache-Aside pattern into your application can significantly enhance performance by reducing database load and speeding up response times for frequently accessed data. By strategically caching query results and invalidating them when updates occur, you can ensure your application remains efficient while maintaining data consistency. However, it's crucial to weigh the potential drawbacks, such as the complexity added by cache management and the risk of stale data. The example implementation provided demonstrates how you can integrate this pattern using the MediatR library, allowing you to introduce caching as a cross-cutting concern in your application's architecture. As always, it's important to assess whether the benefits of this approach align with the specific needs of your application and its users.",
                            Title = "Implementing the Cache-Aside Pattern with MediatR",
                            Version = new byte[0]
                        });
                });

            modelBuilder.Entity("Domain.Articles.Comment", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<int>("ArticleId")
                        .HasColumnType("int");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<DateTime>("EditedDate")
                        .HasColumnType("datetime2");

                    b.Property<int>("UserId")
                        .HasColumnType("int");

                    b.Property<byte[]>("Version")
                        .IsRequired()
                        .HasColumnType("varbinary(max)");

                    b.HasKey("Id");

                    b.HasIndex("ArticleId");

                    b.ToTable("Comments", (string)null);
                });

            modelBuilder.Entity("Domain.Subscribers.Subscriber", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<DateTime>("EditedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<byte[]>("Version")
                        .IsRequired()
                        .HasColumnType("varbinary(max)");

                    b.HasKey("Id");

                    b.ToTable("Subscribers", (string)null);
                });

            modelBuilder.Entity("Domain.Users.User", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<DateTime>("CreatedDate")
                        .HasColumnType("datetime2");

                    b.Property<DateTime>("EditedDate")
                        .HasColumnType("datetime2");

                    b.Property<string>("Emails")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("GoogleId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("LocalId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("MicrosoftId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<byte[]>("Version")
                        .IsRequired()
                        .HasColumnType("varbinary(max)");

                    b.HasKey("Id");

                    b.ToTable("Users", (string)null);
                });

            modelBuilder.Entity("Domain.Articles.Comment", b =>
                {
                    b.HasOne("Domain.Articles.Article", "Article")
                        .WithMany("Comments")
                        .HasForeignKey("ArticleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Article");
                });

            modelBuilder.Entity("Domain.Articles.Article", b =>
                {
                    b.Navigation("Comments");
                });
#pragma warning restore 612, 618
        }
    }
}
